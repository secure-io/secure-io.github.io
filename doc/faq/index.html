<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>FAQ - Secure I/O</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link rel="icon" href="/favicon.png">

  
  
  <link rel="stylesheet" href="/css/style.min.1400022f872516f314ae578022e38d92c97d48d79ca96557c5a4ffdef24e326b.css">
  

  

</head>

<body class='page page-default-single'>
  <div id="main-menu-mobile" class="main-menu-mobile">
  <ul>
    
    
    <li class="menu-item-home">
      <a href="/">
        <span>Home</span>
      </a>
    </li>
    
    <li class="menu-item-documentation">
      <a href="/doc/">
        <span>Documentation</span>
      </a>
    </li>
    
    <li class="menu-item-github">
      <a href="https://github.com/secure-io">
        <span>Github</span>
      </a>
    </li>
    
  </ul>
</div>
  <div class="wrapper">
    <div class='header'>
  <div class="container">
    <div class="logo">
      <a href="/"><img alt="Logo" src="/images/logo.png" /></a>
    </div>
    <div class="logo-mobile">
      <a href="/"><img alt="Logo" src="/images/logo.png" /></a>
    </div>
    <div id="main-menu" class="main-menu">
  <ul>
    
    
    <li class="menu-item-home">
      <a href="/">
        <span>Home</span>
      </a>
    </li>
    
    <li class="menu-item-documentation">
      <a href="/doc/">
        <span>Documentation</span>
      </a>
    </li>
    
    <li class="menu-item-github">
      <a href="https://github.com/secure-io">
        <span>Github</span>
      </a>
    </li>
    
  </ul>
</div>
    <button id="toggle-main-menu-mobile" class="hamburger hamburger--slider" type="button">
  <span class="hamburger-box">
    <span class="hamburger-inner"></span>
  </span>
</button>
  </div>
</div>


    
    
    
    
    
    

    
    <div class="container pt-2 pt-md-6 pb-3 pb-md-6">
      <div class="row">
        <div class="col-12 col-md-3 mb-3">
          <div class="sidebar">
            
<div class="docs-menu">
  <ul>
    
    <li class=" active ">
        <h4><a href="/doc/introduction/">Introduction</a></h4> 
    </li>
    
    <li class="">
        <h4><a href="/doc/faq/">FAQ</a></h4> 
    </li>
    
  </ul>
</div>

          </div>
        </div>
        <div class="col-12 col-md-9">
          
<h1 class="title"><b>FAQ</b></h1>
<div class="content"> 
  <h4 id="why-should-i-use-secure-io">
    <a href="/doc/faq#why-should-i-use-secure-io" style="text-decoration:none">
        Why should I use Secure I/O?
    </a>
</h4>

<p>Actually, there are many different ways to encrypt data. For example, a block
cipher, e.g.
<a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a>, in counter
mode (<a href="https://en.wikipedia.org/wiki/CTR_mode#Counter_(CTR)">CTR</a>) has been and
still is a quite popular encryption scheme. Even though, AES-CTR preserves the
confidentiality of the encrypted data, it provides no integrity protection
whatsoever. In particular, an attacker can flip a bit of the ciphertext and
therefore, can cause a flip of the corresponding plaintext bit during
decryption. AES-CTR cannot detect this and won&rsquo;t return an error. This is
indeed a real problem because an attacker often knows or can guess the
structure and/or parts of the encrypted plaintext.</p>

<p>Therefore, some applications have switched to authenticated encryption
(<a href="https://en.wikipedia.org/wiki/Authenticated_encryption">AEAD</a>) schemes, like
<a href="https://en.wikipedia.org/wiki/Galois/Counter_Mode">AES-GCM</a>. However, AEAD
(on its own) does not solve all security issues w.r.t. data integrity. In
particular, an AEAD only preserves confidentiality and integrity in the
<em>atomic message setting</em> but not when data is processed as stream. For more
details about using AEAD schemes for streaming take a look at this well-written
<a href="https://www.imperialviolet.org/2014/06/27/streamingencryption.html">blog post</a> by
<a href="https://twitter.com/agl__">Adam Langley</a>.</p>

<p>Now, why should you use the scheme implemented by Secure I/O instead of e.g.
AES-GCM?</p>

<p>Well, actually you can use Secure I/O with AES-GCM. In fact, Secure I/O
implements an encryption scheme (<em>secure channel construction</em>) on top of AEAD.
The channel construction splits the plaintext into fixed-size chunks
(<em>fragments</em>) and encrypts and authenticates resp. decrypts and verifies each
fragment separately using the AEAD scheme.</p>

<p>Now, assuming the AEAD scheme is &ldquo;secure&rdquo;, it can be proven that the channel
construction implemented by Secure I/O is &ldquo;secure&rdquo; as well. Take a look at
<a href="/doc/faq#what-does-provable-secure-mean">What does <em>provable secure</em> mean?</a> if
you want to learn more about this.</p>

<p>Also, invoking the AEAD scheme once per fragment instead of only once for the
entire plaintext may sound like a lot of computational overhead. However, this
is not the case. The channel construction is almost as performant as the AEAD
scheme itself. In particular, encrypting plaintexts &gt; 1 MB with the channel
construction is just 1-3% slower than using AES-GCM directly.</p>

<h4 id="what-does-provable-secure-mean">
    <a href="/doc/faq#what-does-provable-secure-mean" style="text-decoration:none">
        What does <i>provable secure</i> mean?
    </a>
</h4>

<h4 id="what-is-a-nonce">
    <a href="/doc/faq#what-is-a-nonce" style="text-decoration:none">
        What's a <i>nonce</i>?
    </a>
</h4>

<p>Nonce stands for: <i><b>n</b>umber used <b>once</b></i> - and that&rsquo;s what it
is. It&rsquo;s a value that must only be used once. Usually, in the context of
encryption, a nonce is associated with a secret key.  So, to be precise, not
the nonce must be unique but the combination of a secret key and a nonce.
In contrast to the secret key, it is not necessary to keep the nonce private.</p>

<p>Why is this important? Because using the same key-nonce combination twice,
usually breaks the security of the encryption scheme such that an attacker
can trivially decrypt ciphertexts or create forgeries.</p>

<p>Therefore, I repeat: <strong>Never use the same key-nonce combination twice!</strong></p>

<p>Easier said than done. Therefore, some recommendations for dealing with nonce
values:</p>

<ul>
<li>Ideally, if you can, use APIs that handle nonce values internally such that
you don&rsquo;t have to care.</li>

<li><p>As an alternative, you can use an unique secret key. Either generate it
randomly or derive it from a master key or password using a appropriate
function (e.g. <a href="https://en.wikipedia.org/wiki/Argon2">Argon2id</a>) - depending on
you application.  If you use unique 256 bit keys, it does not matter how you
choose the nonce.  You can even set it to all zeros in this case. If you use
128 bit keys you should still choose a random nonce since the probability of
choosing a 128 key twice (at random) is not negligible.</p></li>

<li><p>If you have to use the same secret key multiple times then you have to make
sure that you don&rsquo;t use the same nonce value twice. You can apply different
strategies depending on the size of the nonce value:</p>

<ul>
<li>If the nonce is â‰¥ than 160 bits (20 bytes) then you can choose the
nonce value at random (<code>dev/urandom</code> is your friend ðŸ˜‰)
as long as you don&rsquo;t use the same secret key across millions of different
users or applications - which you shouldn&rsquo;t do anyway.</li>
<li>If the nonce is â‰¥ 96 bits (12 bytes) then you can still choose the
nonce at random but not too many times - not more ~4 billion times.
That may sound a lot, but in times of cloud computing this limit can
be reached quickly.</li>
<li>If the nonce is &lt; 96 bits you should not choose the nonce at random.
The best you can do is trying to change the setup such that you can
use unique keys.</li>
</ul></li>
</ul>

<h4 id="what-is-associated-data">
    <a href="/doc/faq#what-is-associated-data" style="text-decoration:none">
            What's <i>associated data</i>?
    </a>
</h4>

<p>Modern encryption schemes encrypt and authenticate data. Usually, this happens
in two steps. First, the encryption scheme produces some ciphertext by
encrypting the plaintext. Then the scheme authenticates the ciphertext by
computing a checksum
(<a href="https://en.wikipedia.org/wiki/Message_authentication_code">MAC</a>) over the
ciphertext and appends this checksum to the ciphertext.</p>

<p>Now, associated data is data that is passed to the encryption scheme to be
authenticated but not encrypted. It is data that is associated to the encrypted
data. Whenever you want to decrypt the ciphertext you also have to provide
exactly the same associated data. Otherwise, the integrity verification of the
encryption scheme will fail and report an error.</p>

<p>This is useful if you want to ensure that some public data, that belongs to the
encrypted data, cannot be modified. For example, consider file encryption. Of
course, nobody (without knowing the secret key) should be able to decrypt a file.
However, an attacker can still e.g. rename or move files to different locations.
Such an attacker can cause quite some confusion.</p>

<p>Therefore, you could use either the file name or the entire (absolute) file path
as associated data. Using the file name prevents renaming the file but allows
moving the file to a different location - e.g. to another directory. In contrast,
using the entire file path also prevents moving the file.</p>

<h4 id="which-algorithm-should-i-use">
    <a href="/doc/faq#which-algorithm-should-i-use" style="text-decoration:none">
        Which algorithm should I use?
    </a>
</h4>

<p>The channel construction implemented by Secure I/O demands an
<a href="https://en.wikipedia.org/wiki/Authenticated_encryption">AEAD</a> scheme.
There are two well-studied and commonly used AEAD:</p>

<ul>
<li><p>AES-GCM<br />
AES-GCM supports 128 (AES-128-GCM) and 256 (AES-256-GCM) bit keys.
Further, it demands a 96 bit nonce. However, since Secure I/O uses
32 bit of the nonce you can only choose 64 bit of it. As explained
in <a href="#what-is-a-nonce">What&rsquo;s a <em>nonce</em>?</a>, you should always use an unique
secret key if you want to use Secure I/O with AES-GCM.</p></li>

<li><p>ChaCha20-Poly1305<br />
ChaCha20-Poly1305 supports 256 bit keys and 96 bit nonce values. Again, since
Secure I/O uses 32 bit of the nonce you can only choose 64 bit of it. As explained
in <a href="#what-is-a-nonce">What&rsquo;s a <em>nonce</em>?</a>, you should always use an unique
secret key if you want to use Secure I/O with ChaCha20-Poly1305.<br />
However, there is a variant of ChaCha20-Poly1305 (XChaCha20-Poly1305) that supports
192 bit nonce values. As mentioned above, Secure I/O reserves 32 bit such that you
can use 160 bit of the nonce. This is sufficiently large such that you can reuse the
secret key for randomly generated nonce values.</p></li>
</ul>

<p>So, which one should I choose?</p>

<p><strong>TL;DR:</strong> Use ChaCha20-Poly1305 - or XChaCha20-Poly1305 if you have to reuse
secret keys.  It is fast on CPUs that provide
<a href="https://en.wikipedia.org/wiki/SIMD">SIMD</a> instructions and implementations are
usually side-channel-resistant.</p>

<p>In general, it depends on the CPU, the programming language resp. AEAD
implementation and the type of your application. It&rsquo;s important to know that
<a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> has been
standardized by the
<a href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.197.pdf">NIST</a>.  Therefore,
it is approved for financial, governmental and military use (in the U.S.).  As a
consequence, many CPU vendors have implemented (parts of) AES in hardware and
provide <a href="https://en.wikipedia.org/wiki/AES_instruction_set">special assembler
instructions</a> to speed up
encryption.<br />
Now, AES (and AES-GCM) implementations are very fast and
side-channel-resistant on CPUs that provide special hardware support. However,
they are much slower and rarely side-channel-resistant on CPUs without such
hardware support.</p>

<p>In contrast, ChaCha20-Poly1305 has been developed as an alternative to AES-GCM
and has been standardized by the <a href="https://www.ietf.org/">IETF</a> in <a href="https://tools.ietf.org/html/rfc7539">RFC
7539</a>. It is quite fast as well if the CPU
provides <a href="https://en.wikipedia.org/wiki/SIMD">SIMD</a> instructions. In addition,
ChaCha20-Poly1305 is much easier to implement securely than AES-GCM.</p>

<p>Concluding, for certain types of applications (financial or governmental) you may
have to use AES-GCM due to legal regulations. Also, if all your CPUs provide
special hardware support for AES then AES-GCM is the straight forward solution.
Otherwise, you may want to use ChaCha20-Poly1305. Anyway, if your biggest problem
is whether you use AES-GCM or ChaCha20-Pol1305 then you don&rsquo;t have problems ðŸ˜‰.</p>

</div>
</div>

        </div>
      </div>
    </div>
    
  </div>

  

  

  
  

  
  <script type="text/javascript" src="/js/scripts.min.bf1e1f7ae8e03db5f012356e825843facdff51c0a559cb0d27fe2bbe1db405c2.js"></script>
  

  
  
  
    
  


</body>

</html>
